# Python is slow

2-10 times slower of equivalent C++ and Java code, because of

- GIL (Global Interpreter Lock, глобальная блокировка интерпретатора)
- интерпретируемость, динамическая типизация

Nodejs(V8 с JIT-компилятором как в JVM) заметно быстрее питона, кроме биндингов типа numpy и ML.

## memory

Memory is divided into two parts in any programming language:

- Heap(specific area of RAM where all values (objects) are stored)
- Stack or run-time stack(store only references pointing toward the values stored in the heap)

## threads

Процесс (Chrome и т. д.) может использовать несколько низкоуровневых структур - потоков (поток) для сложных задач.

Когда интерпретатор CPython создаёт переменные, он выделяет память, а затем подсчитывает количество существующих ссылок на эти переменные. Эта концепция известна как подсчёт ссылок (reference counting). Если число ссылок равняется нулю,тогда соответствующий участок памяти освобождается. Именно поэтому, например, создание «временных» переменных, скажем, в пределах областей видимости циклов, не приводит к чрезмерному увеличению объёма памяти, потребляемого приложением.

Если одними и теми же переменными совместно пользуются несколько потоков, то интерпретатор CPython при подсчёте ссылок инициирует блокировку(locks) - при изменении некоей переменной в памяти, доступ к одной и той же области памяти (для чтения или изменения) не могут одновременно получить несколько потоков, т.е. интерпретатор может выполнять лишь одну операцию за раз, независимо от того, как много потоков имеется в программе.

Если у нас имеется однопоточное приложение, работающее в одном процессе интерпретатора Python, то GIL никак на производительность не влияет.
В многопоточном режиме IO работа(сеть, диск) параллелится замечательно. Во многих реальных задачах потоки ждут i/o операции большую часть времени, так что блокировка GIL может быть незаметна.
Для CPU нагрузки же потоки не помогут.

В JavaScript нет GIL — это изначально однопоточный язык, в отличии от Python(CPython), поэтому в нём подобный механизм и не нужен. Там используется алгоритм сборки мусора mark-and-sweep. Вместо параллельного выполнения кода в JavaScript применяются методики асинхронного программирования, основанные на цикле событий, промисах и коллбэках. В Python есть нечто подобное, представленное модулем asyncio.

## conclusion

Питон надо рассматривать как «мастер»-язык (код который управляет другим кодом, высокоуровневая обертка), поэтому хорошо знать не просто питон а связку Python-C++ или Python-Cython, тогда вопросы скорости отпадут.
На нем удобно всякие инструменты создавать да прототипы.
Если мне нужна программа, которая вычитывает из последовательного порта данные, пакует их в XML и пуляет на удаленный сервер по HTTPS с авторизацией по сертификатам — я напишу ее на Python. Потому что так проще, удобнее и быстрее.
Питон — это не числодробилка. 99% времени программа на Питоне чего-нибудь ждет: ответа от БД, чтения данных с диска, прихода пакета по сети, пользовательского ввода.

Ускорение питона:

- io можно ускорить асинхронщиной (asyncio, curio, trio и тд. и тп.)
- Для тяжелых cpu вычислений с числами можно брать numpy, там почти все на C
- Cперва код, потом оптимизация, узкие места можно на C реализовать
- процессы, asyncio, numpy, cupy, numba, cython решают все проблемы с производительностью.
- PyQt отлично помогает избавиться от проблем производительности в GUI
