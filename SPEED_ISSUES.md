# Python is slow

2-10 times slower of equivalent C++ and Java code, because of

- GIL (Global Interpreter Lock, глобальная блокировка интерпретатора)
- интерпретируемость, динамическая типизация

Nodejs(V8 с JIT-компилятором как в JVM) заметно быстрее питона, кроме биндингов типа numpy и ML.

## memory

Memory is divided into two parts in any programming language:

- Heap(specific area of RAM where all values (objects) are stored)
- Stack or run-time stack(store only references pointing toward the values stored in the heap)

## threads

Процесс (Chrome и т. д.) может использовать несколько низкоуровневых структур - потоков (поток) для сложных задач.

Когда интерпретатор CPython создаёт переменные, он выделяет память, а затем подсчитывает количество существующих ссылок на эти переменные. Эта концепция известна как подсчёт ссылок (reference counting). Если число ссылок равняется нулю,тогда соответствующий участок памяти освобождается. Именно поэтому, например, создание «временных» переменных, скажем, в пределах областей видимости циклов, не приводит к чрезмерному увеличению объёма памяти, потребляемого приложением.

Если одними и теми же переменными совместно пользуются несколько потоков, то интерпретатор CPython при подсчёте ссылок инициирует блокировку(locks) - при изменении некоей переменной в памяти, доступ к одной и той же области памяти (для чтения или изменения) не могут одновременно получить несколько потоков, т.е. интерпретатор может выполнять лишь одну операцию за раз, независимо от того, как много потоков имеется в программе.

Если у нас имеется однопоточное приложение, работающее в одном процессе интерпретатора Python, то GIL никак на производительность не влияет.
В многопоточном режиме IO работа(сеть, диск) параллелится замечательно. Во многих реальных задачах потоки ждут i/o операции большую часть времени, так что блокировка GIL может быть незаметна.
Для CPU нагрузки же потоки не помогут.

В JavaScript нет GIL — это изначально однопоточный язык, в отличии от Python(CPython), поэтому в нём подобный механизм и не нужен. Там используется алгоритм сборки мусора mark-and-sweep. Вместо параллельного выполнения кода в JavaScript применяются методики асинхронного программирования, основанные на цикле событий, промисах и коллбэках. В Python есть нечто подобное, представленное модулем asyncio.

## interpretability

Интерпртируемость в Python довольна эффективна, т.к. на стадии компиляции создаётся .pyc-файл, и последовательность байт-кодов пишется в файл в директории **pycache**/, которая используется и в Python 3, и в Python 2. Подобное применяется не только к написанным нами скриптам, но и к импортированному коду, включая сторонние модули.
В результате, большую часть времени (если только вы не пишете код, который запускается лишь один раз) Python занимается выполнением готового байт-кода.

Java и в C# используется «промежуточный язык», и виртуальная машина Java читает байт-код и выполняет его JIT-компиляцию в машинный код. Однако все это работает быстрее чем питон потому что .NET и в Java используется JIT-компиляция. JIT-компиляция (Just In Time compilation, компиляция «на лету» или «точно в срок») требует наличия промежуточного языка для того, чтобы позволить осуществлять разбиение кода на фрагменты (кадры).
Это означает, что когда некое приложение снова и снова выполняет некие действия, подобная оптимизация способна значительно ускорить выполнение таких действий. Кроме того, не забывайте о том, что Java и C# — это языки со строгой типизацией, поэтому оптимизатор может делать о коде больше предположений, способствующих улучшению производительности программ.

JIT-компилятор есть в PyPy, и, как уже было сказано, эта реализация интерпретатора Python гораздо быстрее, чем CPython.

У JIT-компиляторов есть и недостатки. Один из них — время запуска. CPython и так запускается сравнительно медленно, а PyPy в 2-3 раза медленнее, чем CPython.

Если у вас имеется один процесс Python, который работает длительное время, при этом в таком процессе имеется код, который может быть оптимизирован, так как он содержит интенсивно используемые участки, тогда вам стоит серьёзно взглянуть на интерпретатор, имеющий JIT-компилятор.

Однако, CPython — это реализация интерпретатора Python общего назначения. Поэтому, если вы разрабатываете, с использованием Python, приложения командной строки, то необходимость длительного ожидания запуска JIT-компилятора при каждом запуске этого приложения сильно замедлит работу.

## conclusion

Причиной невысокой производительности Python является его динамическая природа и универсальность. Питон надо рассматривать как «мастер»-язык, который управляет другим кодом, высокоуровневая обертка.
На нем удобно создавать всякие инструменты и прототипы.
Питон — это не числодробилка. 99% времени программа на Питоне чего-нибудь ждет: ответа от БД, чтения данных с диска, прихода пакета по сети, пользовательского ввода.
Проблема производительности не должна волновать, если выбран Python. Если же этот вопрос стоит, то вы ошиблись в первоначальном выборе инструмента для решения задачи. В общем случае в сравнении C, C++ и JAVA, программный код на языке Python проще писать, отлаживать и сопровождать.
Если мне нужна программа, которая вычитывает из последовательного порта данные, пакует их в XML и пуляет на удаленный сервер по HTTPS с авторизацией по сертификатам — я напишу ее на Python. Потому что так проще, удобнее и быстрее.
Процессы, asyncio, numpy, cupy, numba, cython решают все проблемы с производительностью.

Ускорение питона:

- io можно ускорить асинхронщиной (asyncio, curio, trio и тд. и тп.)
- Для тяжелых cpu вычислений с числами можно брать numpy, там почти все на C
- PyQt отлично помогает избавиться от проблем производительности в GUI
- Cперва код, потом оптимизация, узкие места можно на C реализовать
- используйте интерпретатор PyPy если производительность может улучшиться при использовании JIT-компилятора
- Проект Cython объединяет Python и статическую типизацию, что приводит к 84-кратному росту производительности в сравнении с применением обычного Python. Обратите внимание на этот проект, если вам нужна скорость.
